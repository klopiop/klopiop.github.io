[{"content":"0x01 技术介绍 0x01.01 项目介绍 EW下载地址： https://github.com/idlefire/ew#/ 内网穿透 项目介绍：EarthWorm 是一款用于开启 SOCKS v5 代理服务的工具，基于标准 C 开发，可提供多平台间的转接通讯，用于复杂网络环境下的数据转发。\n0x01.02 EW 技术介绍 全称：Earthworm 实现流程： 优点：可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内，还支持多级级联\n0x02 环境\u0026amp;文件准备 安装环境：Ubuntu Server 24.0LTS EW 版本： 最新（8 年前了）\n0x02.01 下载安装 0x02.01.A 自动下载 git 使用命令：\n1 git clone https://gitclone.com/github.com/idlefire/ew.git 进入目录： 0x02.01.B 手动下载 手动文件下载： |选择对应的版本使用 0x03 配置编辑\u0026amp;服务运行 0x 03.01 普通网络环境 有公网： 拓扑： 攻击机-\u0026raquo;靶机\n在目标靶机上使用命令\n1 ./ew -s ssocksd -l 1022 演示：\n使用 proxyfier, 连接成功 无公网： 拓扑： 攻击机-\u0026raquo;公网跳板(/)\u0026laquo;-内网靶机 (192.168.0.2)\n在公网跳板机上使用命令\n1 ./ew -s rcsocks -l 1022 -e 10022 在内网靶机\n1 ./ew -s rssocks -d public_ip -e 10022 此时公网主机通过接受 1080 端口请求，发送给 8888 端口，内网主机接收 8888 端口\n演示：\n| 内网主机开启 | 公网主机开启 | 攻击机测试 0x 03.02 二重网络环境 | 搭建方法类同\n","date":"2024-09-16T00:00:00Z","image":"https://mi0034.icu/p/ew%E4%BB%A3%E7%90%86/cover_hu12970171213084609097.png","permalink":"https://mi0034.icu/p/ew%E4%BB%A3%E7%90%86/","title":"EW代理"},{"content":"0x01 技术介绍 0x01.01 项目介绍 FRP下载地址： https://github.com/fatedier/frp 快速反向代理 项目介绍：快速反向代理，帮助用户将 NAT 或防火墙后面的本地服务器暴露给 Internet\n0x01.02 FRP 隧道技术介绍 | frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议，且支持 P2P 通信\n在 FRP 中，一个代理对应一个需要公开访问的内网服务。一个客户端可以同时配置多个代理，以满足不同的需求。\n0x02 环境\u0026amp;文件准备 安装环境：Ubuntu Server 24.0LTS FRP 版本： 最新\n0x02.01 下载安装 0x02.01.A 自动下载 git 使用命令：\n1 git clone https://gitclone.com/github.com/fatedier/frp.git 进入目录： 0x02.01.B 手动下载 手动文件下载： 选择对应版本下载，解压，进入对应目录\nWget: Linux 下还可以用 wget 程序下载文件 使用命令：\n1 wget https://github.com/fatedier/frp/releases/download/v0.60.0/frp_0.60.0_linux_amd64.tar.gz 之后解压： 使用命令：\n1 tar -zxvf 对应文件名.tar.gz 之后进入对应目录 0x03 配置编辑\u0026amp;服务运行 文件目录结构： | 主要就编辑两个配置文件\n0x03.01 服务端（一般为内网跳板机或者公网服务器） 运行命令： | 旧版配置文件名叫 frps.ini\n1 2 3 4 # 给运行权限 chmod +x frps #运行 ./frps -c ./frps.toml 配置实例：\n1 2 3 4 5 6 # frps.toml bindPort = 7000 # 服务端与客户端通信端口 transport.tls.force = true # 服务端将只接受 TLS链接 auth.token = \u0026#34;public\u0026#34; # 身份验证令牌，frpc要与frps一致 0x03.02 客户端 (一般配置在需要穿透的主机上) 运行命令： | 旧版配置文件名叫 frpc.ini\n1 2 3 4 # 给运行权限 chmod +x frpc #运行 ./frpc -c ./frpc.toml 配置实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # frpc.toml transport.tls.enable = true # 从 v0.50.0版本开始，transport.tls.enable的默认值为 true serverAddr = \u0026#34;x.x.x.x\u0026#34; #自己的公网地址 serverPort = 7000 # 公网服务端通信端口 auth.token = \u0026#34;public\u0026#34; # 令牌，与公网服务端保持一致 [[proxies]] name = \u0026#34;ssh\u0026#34; type = \u0026#34;tcp\u0026#34; localIP = \u0026#34;127.0.0.1\u0026#34; # 需要暴露的服务的IP localPort = 22 # 将本地22端口的服务暴露在公网的6666端口 remotePort = 6666 # 暴露服务的公网入口 [[proxies]] name = \u0026#34;web\u0026#34; type = \u0026#34;tcp\u0026#34; localIP = \u0026#34;127.0.0.1\u0026#34; localPort = 80 remotePort = 8888 0x04 拓展_二层代理实操 0x04.01 环境准备 [!tip] 内网两台主机需要互通\n实验环境：\n攻击机 公网服务器 内网靶机一（出网，已攻陷）192.168.31.200 内网靶机二（不出网）192.168.31.6 实验流程：内网靶机二 22端口映射到内网靶机一 2222端口，最后出网到公网服务器 3559 端口，攻击机连接\n0x04.02 实验过程 0x04.02.A 配置 靶机一配置： | 配置客户端连接公网服务器 | 配置服务端，留给靶机二连接 靶机一配置： | 客户端配置 公网服务端配置：将端口在防火墙放开，配置文件添加对应端口\n0x04.02.B 连接 | 启动靶机一的客户端,服务端 | 启动靶机二的客户端 查看靶机一日志 | 使用公网地址连接 连接成功，执行命令\n0x05 拓展_二层代理实操_2 0x04.01 环境准备 [!tip] 内网两台主机需要互通\n0x04.01.A 实验环境 攻击机 (kali) 公网服务器 内网靶机一（出网，已攻陷）192.168.0.2|10.0.0.3 内网靶机二（不出网）10.0.0.2 实验流程：靶机一是双网卡主机联通两个网段，靶机二不出网，并设置有数据库\n0x04.01.B 配置 [!tip] 此次实验环境使用 docker 配置\nDocker： 目录结构： project/ ├── docker-compose.yml ├── Dockerfile.First_layer ├── Dockerfile.Second_layer ├── init.sql\n运行命令：\n1 2 3 4 # 启动!！ docker compose up -d # 查看状态 docker ps 配置内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # docker-compose.yml version: \u0026#39;3.8\u0026#39; services: first_layer: build: context: . dockerfile: Dockerfile.first_layer container_name: first_layer tty: true stdin_open: true networks: external_net: ipv4_address: 192.168.0.2 internal_net: aliases: - first_layer ports: - \u0026#34;2222:22\u0026#34; second_layer: build: context: . dockerfile: Dockerfile.second_layer container_name: second_layer tty: true stdin_open: true networks: internal_net: ipv4_address: 10.0.0.2 environment: MYSQL_ROOT_PASSWORD: root@123 volumes: mysql_data: networks: external_net: driver: bridge ipam: driver: default config: - subnet: 192.168.0.0/24 internal_net: driver: bridge ipam: driver: default config: - subnet: 10.0.0.0/24 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Dockerfile.first_layer FROM ubuntu:latest RUN apt-get update \u0026amp;\u0026amp; apt-get install -y wget openssh-server RUN wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz \u0026amp;\u0026amp; \\ tar -zxvf frp_0.38.0_linux_amd64.tar.gz \u0026amp;\u0026amp; \\ mv frp_0.38.0_linux_amd64/frp /usr/local/bin/ \u0026amp;\u0026amp; \\ rm -rf frp_0.38.0_linux_amd64.tar.gz frp_0.38.0_linux_amd64 # SSH配置 RUN mkdir /var/run/sshd RUN echo \u0026#39;root:root\u0026#39; | chpasswd RUN sed -i \u0026#39;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config # SSH登录修复 RUN sed -i \u0026#39;s@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g\u0026#39; /etc/pam.d/sshd EXPOSE 22 CMD [\u0026#34;/usr/sbin/sshd\u0026#34;, \u0026#34;-D\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 # Dockerfile.second_layer FROM ubuntu:latest RUN apt-get update \u0026amp;\u0026amp; apt-get install -y mysql-server wget RUN wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz \u0026amp;\u0026amp; \\ tar -zxvf frp_0.38.0_linux_amd64.tar.gz \u0026amp;\u0026amp; \\ mv frp_0.38.0_linux_amd64/frp /usr/local/bin/ \u0026amp;\u0026amp; \\ rm -rf frp_0.38.0_linux_amd64.tar.gz frp_0.38.0_linux_amd64 # MySQL配置 ENV MYSQL_ROOT_PASSWORD=root@123 COPY init.sql /docker-entrypoint-initdb.d/ EXPOSE 3306 CMD [\u0026#34;mysqld\u0026#34;] 1 2 3 4 # init.sql CREATE DATABASE IF NOT EXISTS exampledb; GRANT ALL PRIVILEGES ON exampledb.* TO \u0026#39;exampleuser\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;examplepassword\u0026#39;; FLUSH PRIVILEGES; frp: ssh 连接： 查看网卡信息： 可互通： 分别配置 frp: | 靶机 2 客户端 | 靶机 1 客户端/服务端 0x04.02 实验过程 0x04.02.A 连接数据库 ","date":"2024-09-16T00:00:00Z","image":"https://mi0034.icu/p/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/cover_hu14924921527619774239.png","permalink":"https://mi0034.icu/p/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","title":"FRP内网穿透"},{"content":"0x01 文档及项目介绍 0x01.01 文档介绍 😀引子： 因为自己本身就使用hugo搭建了自己的博客，那么本着分享自己的搭建经验和一些体验心得，个人认为可能可以给到大家一个小小的参考吧。\n😊那么接下来就进入正片吧~~~\n0x01.02 项目介绍 简单来讲呢，就是一个快速的静态站点生成器，专门对速度进行了优化，可以在几秒内呈现完整网站（😉不是自己部署的时候哦，是生成页面的时候）\n0x02 部署 0x02.01 环境介绍 操作系统：win11 git：latest hugo：latest\n0x02.02 支撑环境安装 0x02.02.a Git 项目地址： Git下载地址： https://git-scm.com/download/win 一个项目管理工具 选择下载 打开下载好的安装包进行安装,下一步 自己选择默认的编辑器，我是vscode 一直下一步，看到install，安装就行 0x02.02.b hugo 获取hugo： hugo下载地址： [https://github.com/gohugoio/hugo/releases](https://github.com/gohugoio/hugo/releases) 一个项目管理工具 选择对应包下载（选择带extended字样，包含完整拓展的） 创建hugo目录，丢进去就行（自定义） 创建环境变量，方便调用 测试安装情况 0x02.03 博客本地部署 找一个心仪的目录用来创建站点文件夹（博客目录） 初始化站点 使用命令\n1 2 # 在目录下启动cmd hugo new site blog 进入文件夹 0x02.04 博客Github部署 ","date":"2024-09-15T00:00:00Z","image":"https://mi0034.icu/p/hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%95%E6%93%8E/cover_hu10642907274495543336.png","permalink":"https://mi0034.icu/p/hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%95%E6%93%8E/","title":"hugo个人博客引擎"},{"content":"0x01 技术介绍 0x01.01 项目介绍 [!info] 一般用于 web 渗透环境\nreGeorg项目地址： https://github.com/sensepost/reGeorg suo5下载地址： https://github.com/L-codes/Neo-reGeorg Neo-reGeorg 项目介绍：Neo-reGeorg 是一个寻求积极重构 reGeorg 的项目\n提高可用性，避免特征检测 提高 tunnel 连接安全性 提高传输内容保密性 应对更多的网络环境场景下使用 ReGeorg 项目介绍：pwn 堡垒 Web 服务器并通过 DMZ 创建 SOCKS 代理。Pivot 和 pwn\n0x02 环境\u0026amp;文件准备 安装环境：Ubuntu Server 24.0 LTS Neo-reGeorg 版本：最新\n0x02.01 下载安装 0x02.01.A 本地脚本生成 下载 解压 生成脚本 使用命令：\n1 python neoreg.py generate -k password 生成的文件 0x03 连接 | 上传至服务器中，进行连接 使用命令\n1 python neoreg.py -k \u0026lt;已经设定的密钥\u0026gt; -u \u0026lt;http://xxx.xxx.xxx/tunnel.aspx\u0026gt; -p \u0026lt;prot\u0026gt; ","date":"2024-09-15T00:00:00Z","image":"https://mi0034.icu/p/neo-regeorg%E4%BB%A3%E7%90%86/cover_hu7010524211425556387.png","permalink":"https://mi0034.icu/p/neo-regeorg%E4%BB%A3%E7%90%86/","title":"Neo-reGeorg代理"},{"content":"0x01 技术介绍 0x01.01 项目介绍 NPS下载地址： https://github.com/ehang-io/nps#/ 一款轻量级、高性能、功能强大的内网穿透代理服务器 项目介绍：一款轻量级、高性能、功能强大的内网穿透代理服务器。支持 tcp、udp、socks5、http 等几乎所有流量转发，可用来访问内网网站、本地支付接口调试、ssh 访问、远程桌面，内网 dns 解析、内网 socks5代理，项目功能很强大，还有官方的安卓客户端\n0x01.01 NPS技术介绍 NPS 通过在拥有公网 IP 的服务器上部署服务端，以及在内网目标机器上部署客户端，建立起一条从公网到内网的隧道。服务端监听公网 IP 上的特定端口，当外部请求到达这些端口时，NPS 服务端将流量通过隧道转发到内网的客户端，再由客户端转发到内网的目标机器上。这样，即使目标机器位于内网，也可以通过公网 IP 和相应的端口访问到它\n0x02 环境\u0026amp;文件准备 安装环境：Ubuntu Server 24.0 LTS GO 版本：2:1.21~2 NPS 版本： 最新\n0x02.01 下载安装 0x02.01.A 自动下载 git [!error] 这里不建议使用 git，因为还需要自己编译，对环境有要求\n使用命令：\n1 git clone https://gitclone.com/github.com/ehang-io/nps.git 进入目录，进行编译： 使用命令：\n1 2 3 4 5 6 # 进行更新 sudo apt update --upgrade # 添加权限 sudo chmod +x build.sh # 运行构建 sudo ./build.sh 0x02.01.B 手动下载 手动文件下载： 选择对应的系统，下载服务端和客户端 | 将客户端上传到需要穿透的主机 安装： 使用命令：\n1 ./npc install | 将服务端上传到公网主机 0x03 配置编辑\u0026amp;服务运行 0x03.01 服务端配置 |可以根据自身情况调整\n| 启动后进入 web | 配置 web 端，给客户端连接做准备 | 分别设置 http，socks，tcp 隧道 | 获取配置信息 回到客户端界面，点击客户端前的小加号获取 0x03.02 客户端配置 |可以根据自身情况调整 | 使用配置启动\n1 ./npc -server=public_ip -vkey=miaomiao@123 -type=tcp | 开放防火墙 0x04 补充 | 需关闭\n1 npc stop ","date":"2024-09-15T00:00:00Z","image":"https://mi0034.icu/p/nps%E4%BB%A3%E7%90%86/cover_hu13649474688866500571.png","permalink":"https://mi0034.icu/p/nps%E4%BB%A3%E7%90%86/","title":"NPS代理"},{"content":"0x01 技术介绍 0x01.01 项目介绍 SSH下载地址： https://github.com/openssh/openssh-portable 一个便携式 OpenSSH 项目介绍：SSH (Secure Shell) 不仅是安全远程管理的工具，也是在主机之间创建安全隧道的强大工具\n0x02 环境\u0026amp;文件准备 安装环境：Ubuntu Server 24.0 LTS | windows 11 SSH 版本：最新\n0x02.01 下载安装 使用命令：\n1 2 3 4 5 6 7 8 #更新 sudo apt update # 安装openssh服务器 sudo apt install openssh-server # 检查 sudo systemctl status ssh 0x02.02 配置 使用命令：\n1 2 # 进入配置文件 sudo nano /etc/ssh/sshd_config 0x03 建立隧道 [!info] 搭建 web 进行测试\n0x03.01 正向隧道 正向 SSH 的场景中，目标服务器或服务通常位于客户端可以直接或间接访问的网络中\n[!tip] 提示 这里可能很多人会有误解，在目标 ip 上填写的私网地址是相对于公网服务器来说的，也就是公网服务器所处的一个不对外的内网环境\n| 本地 使用命令：\n1 2 # ssh服务器与目标服务是一台主机 ssh -L 8087:localhost:8080 root@public_ip 内网 ：ip=10.0.0.2 | 代理成功 0x03.02 反向隧道 将远程服务器上的端口转发到本地机器上的端口的过程，当设置一个反向 SSH 隧道时，实际上是在远程服务器上创建了一个端口，当访问这个端口时，流量会通过 SSH 隧道转发到连接的本地机器的指定端口\n| 相当于一个端口转发，类似于 frp 吧 | 内网服务器 使用命令：\n1 ssh -R 8087:localhost:8080 root@public_ip ","date":"2024-09-15T00:00:00Z","image":"https://mi0034.icu/p/ssh%E9%9A%A7%E9%81%93/cover_hu7537671703254225128.png","permalink":"https://mi0034.icu/p/ssh%E9%9A%A7%E9%81%93/","title":"SSH隧道"},{"content":"0x01 技术介绍 0x01.01 项目介绍 suo5下载地址： https://github.com/zema1/suo5#/ 一款高性能 HTTP 代理隧道工具 项目介绍：一款高性能 HTTP 代理隧道工具，属于对网站端口的复用吧，走的 TCP 协议\n0x02 环境\u0026amp;文件准备 安装环境：Ubuntu Server 24.0 LTS | tomcat suo5 版本： 最新\n0x02.01 下载安装 | 选择适合的版本 | 服务端有普通技术栈和 java 技术栈两个选择 0x02.01 下载安装 | windows 可以直接使用 gui 客户端 0x03 开始代理 0x03.01 正向代理 | 上传之后连接 这里使用 CVE-2017-12615 漏洞环境测试 | 看看网页情况，tomcat 7.0.79 | 上传 suo5 的文件 | 成功连接 0x03.01 反向代理 | 在 Nginx+Tomcat 环境中呢，Nginx 处理 Chunked-Encoding 类型的 Body 时会缓存 Body 的情况下，Suo5 也能够通过特定的响应头 X-Accel-Buffering: no 来绕过这一限制，实现数据的直连传输\n","date":"2024-09-15T00:00:00Z","image":"https://mi0034.icu/p/suo5%E9%9A%A7%E9%81%93/cover_hu17737958624241623583.png","permalink":"https://mi0034.icu/p/suo5%E9%9A%A7%E9%81%93/","title":"suo5隧道"},{"content":"0x01 什么是内网穿透 都知道，实际场景的网络环境，分为内网和外网，内网穿透，简单地说就是内网的数据让外网可以获取，可以映射到公共网络上，这样就可以在公共网络上访问内网的数据。 像是普通的家庭网络或者企业的内部通信网络，就都属于内网，需要外部人员访问，就需要将内网资源映射到公网上，这就是内网穿透。 内网穿透发明初期是为了方便运维人员对内部网络资源进行维护管理，但是这项技术也成为了威胁内网安全的一把利剑，让威胁者可以轻松的窃取、破坏内网数据。 0x02什么是端口转发 | 其实这项技术就是字面意思，但是具体哪个端口转发到哪个端口要以应用场景为准\n已经与内网中的某台终端设备建立了连接 确保这台设备可以访问到 taget 靶机 将靶机的目标端口映射到我们可以访问的内网终端设备的端口上，实现流量转发 0x02.01 端口映射 | 端口映射跟端口转发有些许区别，假设 A 和 B 在不同的内网，各自有自己的内网 IP，但是互相无法直接访问，这时就需要一个中间服务器\n0x03 什么是代理技术 | 我们现在一张图中找找灵感 0x03.01 正向代理 设备：\n客户端A 原始服务器B 代理服务器C 为了从原始服务器取得内容，用户 A 向代理服务器 C 发送一个请求并指定目标(服务器 B)，然后代理服务器 C 向服务器 B 转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。\n主要应用：VPN 或者 FQ 上网 一般用于内网用户访问外网服务，像是防火墙\n0x03.02 反向代理 | 反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，客户端不需要进行任何特别的设置，反向代理对外的表现都是透明的，客户不知道自己访问的是代理服务器，客户端也不需要任何配置就可以访问。\n客户端向反向代理的命名空间（name-space）请求，由反向代理判断指向何处（原始服务器），最后给客户返回结果。\n主要应用：安全、负载均衡方面的常用配置 一般用于 internet 用户访问内网资源时\n0x03.03 透明代理 | 透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的 request fields（报文），并会传送真实 IP。透明代理实践的例子就是时下很多公司使用的行为管理软件。\n设备：\n客户端 透明代理服务器 原始服务器 当客户端向原始服务器请求时，透明代理设备根据自身策略拦截并修改客户端的报文，并作为实际的请求方，向原始服务器发送请求。当接收信息回传，透明代理再根据自身的设置把允许的报文发回至客户端\n主要应用：防火墙、行为管理软件\n","date":"2024-09-15T00:00:00Z","image":"https://mi0034.icu/p/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/cover_hu12970171213084609097.png","permalink":"https://mi0034.icu/p/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/","title":"端口转发与代理"}]